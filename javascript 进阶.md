# javascript 进阶

@(进阶要点)[盲点|重点]

**马克飞象**是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述：
 
- **功能丰富** ：支持高亮代码块、*LaTeX* 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手；
- **得心应手** ：简洁高效的编辑器，提供[桌面客户端][1]以及[离线Chrome App][2]，支持移动端 Web；
- **深度整合** ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。

-------------------

[TOC]

## 值类型 引用类型的理解
``` javascript
var a = {"x": 1};
var b = a;
a.x = 2;
b.x;

a = {"x":3};
console.log(b.x);
a.x == 4;
console.log(b.x);
```
> **console 结果**　2 / 2 
## 闭包+作用域/作用域链+单线程+垃圾回收
###闭包
``` javascript
function foo(){
    var x = 1;
    return function (){
        alert(++x); //2
    }
}
var bar = foo();
bar();
```
> **闭包的产生原理：** 在JavaScript中，函数可以用来分隔作用域，当foo执行（activation）的时候，产生了一个foo的动态作用域，然后这个动态作用域把变量x和那个return的匿名函数装（push到栈）了进去，一般情况下，当函数执行完毕时，它会自动销毁（pop出栈）内部产生的变量和函数，跳出这个作用域环境，返回到上一层（context）。但是在这里，由于foo作用域内部的变量和函数与它作用域外部的变量bar存在暧昧关系（bar引用了foo()的返回值），所以变量x和匿名函数没法从foo作用域中被销毁，于是也就产生了我们平时所说的闭包。刚才说的push到栈和pop出栈很已经显然不适用于闭包，这和栈的结构是相悖的，那么闭包是怎样的内存分配方式呢？这个我们后面再说。闭包既不是foo函数，也不是那个匿名函数，而是变量x、匿名函数、上下文环境三者一起同时存在的结果
> **存在有这么两个条件：**  
> - 没有被创建它的上下文销毁 
> - 引用了自由变量（没有在函数块中定义，也没有从arguments中送入，如上匿名函数中的变量x，就是一个自由变量）
>
> 
> **闭包作用：**模拟面向对象的代码风格；更优雅，更简洁的表达出代码；在某些方面提升代码的执行效率 
> - 匿名自执行函数
> - 缓存
> - 实现封装
> - 闭包的另一个重要用途是实现面向对象中的对象，传统的对象语言都提供类的模板机制这样不同的对象(类的实例)拥有独立的成员及状态，互不干涉，通过使用闭包，我们可以模拟出这样的机制
###开发进阶：理解作用域和作用域链
> **作用域**
> 全局作用域（Global Scope）
> - 最外层函数和在最外层函数外面定义的变量拥有全局作用域
> - 所有末定义直接赋值的变量自动声明为拥有全局作用域 
> - 所有window对象的属性拥有全局作用域
>
> 
> 局部作用域（Local Scope）
> - 和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部
>
>
> **作用域链**
> 在JavaScript中，函数也是对象，实际上，JavaScript里一切都是对象。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个内部属性是[[Scope]]，由ECMA-262标准第三版定义，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。
> 当一个函数创建后，它的作用域链会被创建此函数的作用域中可访问的数据对象填充
>```javascript
function add(num1,num2) {
    var sum = num1 + num2;
    return sum;
}
>```
>在函数add创建时，它的作用域链中会填入一个全局对象，该全局对象包含了所有全局变量
>![enter image description here](http://pic002.cnblogs.com/images/2011/36987/2011090414435366.jpg)
>函数add的作用域将会在执行时用到。例如执行如下代码：
>```javascript
var total = add(5,10);
>```
>执行此函数时会创建一个称为“运行期上下文(execution context)”的内部对象，运行期上下文定义了函数执行时的环境。每个运行期上下文都有自己的作用域链，用于标识符解析，当运行期上下文被创建时，而它的作用域链初始化为当前运行函数的[[Scope]]所包含的对象。
>这些值按照它们出现在函数中的顺序被复制到运行期上下文的作用域链中。它们共同组成了一个新的对象，叫“活动对象(activation object)”，该对象包含了函数的所有局部变量、命名参数、参数集合以及this，然后此对象会被推入作用域链的前端，当运行期上下文被销毁，活动对象也随之销毁。
>![enter image description here](http://pic002.cnblogs.com/images/2011/36987/2011090414444843.jpg)
>在函数执行过程中，每遇到一个变量，都会经历一次标识符解析过程以决定从哪里获取和存储数据。该过程从作用域链头部，也就是从活动对象开始搜索，查找同名的标识符，如果找到了就使用这个标识符对应的变量，如果没找到继续搜索作用域链中的下一个对象，如果搜索完所有对象都未找到，则认为该标识符未定义。函数执行过程中，每个标识符都要经历这样的搜索过程。
>**作用域链和代码优化**
>从作用域链的结构可以看出，在运行期上下文的作用域链中，标识符所在的位置越深，读写速度就会越慢。如上图所示，因为全局变量总是存在于运行期上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。一个好的经验法则是：如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用。
>```javascript
function changeColor(){
    document.getElementById("btnChange").onclick=function(){
        document.getElementById("targetCanvas").style.backgroundColor="red";
    };
}
>```
>这个函数引用了两次全局变量document，查找该变量必须遍历整个作用域链，直到最后在全局对象中才能找到。这段代码可以重写如下：
>```javascript
function changeColor(){
    var doc=document;
    doc.getElementById("btnChange").onclick=function(){
        doc.getElementById("targetCanvas").style.backgroundColor="red";
    };
}
>```
>这段代码比较简单，重写后不会显示出巨大的性能提升，但是如果程序中有大量的全局变量被从反复访问，那么重写后的代码性能会有显著改善。
>**改变作用域链**
>函数每次执行时对应的运行期上下文都是独一无二的，所以多次调用同一个函数就会导致创建多个运行期上下文，当函数执行完毕，执行上下文会被销毁。每一个运行期上下文都和一个作用域链关联。一般情况下，在运行期上下文运行的过程中，其作用域链只会被 with 语句和 catch 语句影响。
>with语句是对象的快捷应用方式，用来避免书写重复代码。例如：
>```javascript
function initUI(){
    with(document){
        var bd=body,
            links=getElementsByTagName("a"),
            i=0,
            len=links.length;
        while(i < len){
            update(links[i++]);
        }
        getElementById("btnInit").onclick=function(){
            doSomething();
        };
    }
}
>```
>这里使用width语句来避免多次书写document，看上去更高效，实际上产生了性能问题。
>当代码运行到with语句时，运行期上下文的作用域链临时被改变了。一个新的可变对象被创建，它包含了参数指定的对象的所有属性。这个对象将被推入作用域链的头部，这意味着函数的所有局部变量现在处于第二个作用域链对象中，因此访问代价更高了。如下图所示：
>![enter image description here](http://pic002.cnblogs.com/images/2011/36987/2011090414454524.jpg)
>因此在程序中应避免使用with语句，在这个例子中，只要简单的把document存储在一个局部变量中就可以提升性能。
>另外一个会改变作用域链的是try-catch语句中的catch语句。当try代码块中发生错误时，执行过程会跳转到catch语句，然后把异常对象推入一个可变对象并置于作用域的头部。在catch代码块内部，函数的所有局部变量将会被放在第二个作用域链对象中。示例代码：
>```javascript
try{
    doSomething();
}catch(ex){
    alert(ex.message); //作用域链在此处改变
}
>```
>请注意，一旦catch语句执行完毕，作用域链机会返回到之前的状态。try-catch语句在代码调试和异常处理中非常有用，因此不建议完全避免。你可以通过优化代码来减少catch语句对性能的影响。一个很好的模式是将错误委托给一个函数处理，例如：
>```javascript
try{
    doSomething();
}catch(ex){
    handleError(ex); //委托给处理器方法
}
>```
>优化后的代码，handleError方法是catch子句中唯一执行的代码。该函数接收异常对象作为参数，这样你可以更加灵活和统一的处理错误。由于只执行一条语句，且没有局部变量的访问，作用域链的临时改变就不会影响代码性能了。

###单线程
>**Javascript是单线程的**
>因为JS运行在浏览器中，是单线程的，每个window一个JS线程，既然是单线程的，在某个特定的时刻只有特定的代码能够被执行，并阻塞其它的代码。而浏览器是事件驱动的（Event driven），浏览器中很多行为是异步（Asynchronized）的，会创建事件并放入执行队列中。javascript引擎是单线程处理它的任务队列，你可以理解成就是普通函数和回调函数构成的队列。当异步事件发生时，如mouse click, a timer firing, or an XMLHttpRequest completing（鼠标点击事件发生、定时器触发事件发生、XMLHttpRequest完成回调触发等），将他们放入执行队列，等待当前代码执行完成。
>**异步事件驱动**
>前面已经提到浏览器是事件驱动的（Event driven），浏览器中很多行为是异步（Asynchronized）的，例如：鼠标点击事件、窗口大小拖拉事件、定时器触发事件、XMLHttpRequest完成回调等。当一个异步事件发生的时候，它就进入事件队列。浏览器有一个内部大消息循环，Event Loop（事件循环），会轮询大的事件队列并处理事件。例如，浏览器当前正在忙于处理onclick事件，这时另外一个事件发生了（如：window onSize），这个异步事件就被放入事件队列等待处理，只有前面的处理完毕了，空闲了才会执行这个事件。setTimeout也是一样，当调用的时候，js引擎会启动定时器timer，大约xxms以后执行xxx，当定时器时间到，就把该事件放到主事件队列等待处理（浏览器不忙的时候才会真正执行）。每个浏览器具体实现主事件队列不尽相同。
>**浏览器不是单线程的**
>虽然JS运行在浏览器中，是单线程的，每个window一个JS线程，但浏览器不是单线程的，例如Webkit或是Gecko引擎，都可能有如下线程：
> - javascript引擎线程
> - 界面渲染线程
> - 浏览器事件触发线程
> - Http请求线程
>
>
> 如果js是单线程的，那么谁去轮询大的Event loop事件队列？答案是浏览器会有单独的线程去处理这个队列。
>**Ajax异步请求是否真的异步?**
>既然说JavaScript是单线程运行的，那么XMLHttpRequest在连接后是否真的异步? 
>其实请求确实是异步的，这请求是由浏览器新开一个线程请求（见前面的浏览器多线程）。当请求的状态变更时，如果先前已设置回调，这异步线程就产生状态变更事件放到 JavaScript引擎的事件处理队列中等待处理。当浏览器空闲的时候出队列任务被处理，JavaScript引擎始终是单线程运行回调函数。javascript引擎确实是单线程处理它的任务队列，能理解成就是普通函数和回调函数构成的队列。
>总结一下，Ajax请求确实是异步的，这请求是由浏览器新开一个线程请求，事件回调的时候是放入Event loop单线程事件队列等候处理。
>**非阻塞js的实现**
> - HTML5的defer和async关键字
> - 动态加载js

###垃圾回收
>JavaScript的解释器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时候，他就知道不再需要这个对象，可以把它所占用的内存释放掉了。但是这个过程不是时时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。
>**变量生命周期**
>不再使用的变量也就是生命周期结束的变量，当然只可能是局部变量，全局变量的生命周期直至浏览器卸载页面才会结束。局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值，然后再函数中使用这些变量，直至函数结束（闭包中由于内部函数的原因，外部函数并不能算是结束）
>一旦函数结束，局部变量就没有存在必要了，可以释放它们占用的内存。貌似很简单的工作，为什么会有很大开销呢？这仅仅是垃圾回收的冰山一角，就像刚刚提到的闭包，貌似函数结束了，其实还没有，垃圾回收器必须标记那个变量有用，那个变量没用，对于不再有用的变量打上标记，以备将来回收。用于标记无用的策略有很多，常见的有两种方式
> - 标记清除（mark and sweep）
>        这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。至于怎么标记有很多种方式，比如特殊位的反转、维护一个列表等，这些并不重要，重要的是使用什么策略，原则上讲不能够释放进入环境的变量所占的内存，它们随时可能会被调用的到。
>      垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了，因为环境中的变量已经无法访问到这些变量了，然后垃圾回收器相会这些带有标记的变量机器所占空间。
>     大部分浏览器都是使用这种方式进行垃圾回收，区别在于如何标记及垃圾回收间隔而已
> - 引用计数(reference counting)
>     在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。
### 构造函数+设计模式+对类的理解
####构造函数
>**定义类（class）的三种方法**
> - 构造函数法
>      构造函数模拟"类"，在其内部用this关键字指代实例对象
>```javascript
function Cat() {
	this.name = "大毛";
}
var cat1 = new Cat();
alert(cat1.name); // 大毛
Cat.prototype.makeSound = function(){
	alert("喵喵喵");
}
>```
>   生成实例的时候，使用new关键字。类的属性和方法，还可以定义在构造函数的prototype对象之上。
> - Object.create()法
>    这个方法，"类"就是一个对象，不是函数
>```javascript
var Cat = {
	name: "大毛",
	makeSound: function(){ alert("喵喵喵"); }
};
var cat1 = Object.create(Cat);
var cat2 = Object.create(Cat);
cat2.name = "cat2";
alert(cat1.name); // 大毛
alert(cat2.name); // cat2
>```
>    然后，直接用Object.create()生成实例，不需要用到new。
>    这种方法比"构造函数法"简单，但是不能实现私有属性和私有方法，实例对象之间也不能共享数据，对"类"的模拟不够全面。
> - 极简主义法
>  -- **封装**
>   首先，它也是用一个对象模拟"类"。在这个类里面，定义一个构造函数createNew()，用来生成实例。
>```javascript
var Cat = {
　　createNew: function(){
　　　　var cat = {};
　　　　cat.name = "大毛";
　　　　cat.makeSound = function(){ alert("喵喵喵"); };
　　　　return cat;
　　}
};
var cat1 = Cat.createNew();
cat1.makeSound(); // 喵喵喵
>```
>  使用的时候，调用createNew()方法，就可以得到实例对象
> -- **继承**
>让一个类继承另一个类，实现起来很方便。只要在前者的createNew()方法中，调用后者的createNew()方法即可



### 原型链+继承+ES5+继承优化
